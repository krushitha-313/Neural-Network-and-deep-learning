# mnist_cnn.py
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.utils import to_categorical

# 1) Load MNIST dataset (built into Keras)
(x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data()

# 2) Preprocess: normalize and expand dims for channels
x_train = x_train.astype("float32") / 255.0
x_test  = x_test.astype("float32")  / 255.0

# add channel dimension (28,28) -> (28,28,1)
x_train = np.expand_dims(x_train, -1)
x_test  = np.expand_dims(x_test, -1)

# one-hot labels
y_train_cat = to_categorical(y_train, 10)
y_test_cat  = to_categorical(y_test, 10)

# 3) Build a small CNN
def make_model():
    model = models.Sequential([
        layers.Input(shape=(28,28,1)),
        layers.Conv2D(32, (3,3), activation='relu'),
        layers.MaxPooling2D((2,2)),
        layers.Conv2D(64, (3,3), activation='relu'),
        layers.MaxPooling2D((2,2)),
        layers.Flatten(),
        layers.Dense(128, activation='relu'),
        layers.Dropout(0.4),
        layers.Dense(10, activation='softmax')
    ])
    model.compile(
        optimizer='adam',
        loss='categorical_crossentropy',
        metrics=['accuracy']
    )
    return model

model = make_model()
model.summary()

# 4) Train
history = model.fit(
    x_train, y_train_cat,
    epochs=6,                 # change to 10-15 for better accuracy
    batch_size=128,
    validation_split=0.1,
    verbose=2
)

# 5) Evaluate on test set
test_loss, test_acc = model.evaluate(x_test, y_test_cat, verbose=0)
print(f"Test accuracy: {test_acc:.4f}, Test loss: {test_loss:.4f}")

# 6) Save model
model.save("mnist_cnn.h5")
print("Model saved to mnist_cnn.h5")

# 7) Example: predict some test images and show them
preds = model.predict(x_test[:10])
pred_labels = np.argmax(preds, axis=1)

plt.figure(figsize=(10,3))
for i in range(10):
    plt.subplot(2,5,i+1)
    plt.imshow(x_test[i].squeeze(), cmap='gray')
    plt.title(f"pred:{pred_labels[i]} / true:{y_test[i]}")
    plt.axis('off')
plt.tight_layout()
plt.show()

# 8) Utility: predict a single image (28x28 numpy array scaled 0-1)
def predict_single(img_28x28):
    img = img_28x28.astype("float32") / 255.0
    img = np.expand_dims(img, axis=(0,-1))  # shape (1,28,28,1)
    p = model.predict(img)
    return np.argmax(p), np.max(p)

# Example usage:
# predicted_digit, confidence = predict_single(x_test[0].squeeze())
# print(predicted_digit, confidence)
